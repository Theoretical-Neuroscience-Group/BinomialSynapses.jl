var documenterSearchIndex = {"docs":
[{"location":"#BinomialSynapses.jl","page":"BinomialSynapses.jl","title":"BinomialSynapses.jl","text":"","category":"section"},{"location":"#Models","page":"BinomialSynapses.jl","title":"Models","text":"","category":"section"},{"location":"","page":"BinomialSynapses.jl","title":"BinomialSynapses.jl","text":"AbstractBinomialModel\nBinomialGridModel\nBinomialGridModel(\n    Nind, pind, qind, σind, τind,\n    Nrng, prng, qrng, σrng, τrng\n)\nBinomialGridModel(m_out::Integer, my_Nrng, my_prng, my_qrng, my_σrng, my_τrng)\nBinomialModel\nBinomialModel(Nmax::Integer, m_out::Integer, device = :gpu)\nBinomialModel(m_out::Integer, my_Nrng, my_prng, my_qrng, my_σrng, my_τrng)\nBinomialModel(model::BinomialGridModel)\nScalarBinomialModel\nBinomialState(Nmax::Integer, m_out::Integer, m_in::Integer, device::Symbol = :gpu)\nScalarBinomialState\nBinomialObservation\npropagate!(state::BinomialState, model, dt)\nemit","category":"page"},{"location":"#BinomialSynapses.AbstractBinomialModel","page":"BinomialSynapses.jl","title":"BinomialSynapses.AbstractBinomialModel","text":"AbstractBinomialModel\n\nAn abstract type for binomial synaptic models. A binomial model always has the following parameters:\n\nN: number of release sites\np: probability of release\nq: quantum of release\nσ: observation noise\nτ: refilling time constant\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.BinomialGridModel","page":"BinomialSynapses.jl","title":"BinomialSynapses.BinomialGridModel","text":"BinomialGridModel(\n    Nind, pind, qind, σind, τind,\n    Nrng, prng, qrng, σrng, τrng,\n    N,    p,    q,    σ,    τ\n   )\n\nA binomial model ensemble whose parameters are constrained to live on a grid defined by Nrng, prng, etc.\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.BinomialGridModel-NTuple{10, Any}","page":"BinomialSynapses.jl","title":"BinomialSynapses.BinomialGridModel","text":"BinomialGridModel(\n    Nind, pind, qind, σind, τind,\n    Nrng, prng, qrng, σrng, τrng\n)\n\nConstruct a binomial model ensemble with parameters on a grid, e.g. Nrng,  based on choosing indices, e.g. Nind.\n\n\n\n\n\n","category":"method"},{"location":"#BinomialSynapses.BinomialGridModel-Tuple{Integer, Any, Any, Any, Any, Any}","page":"BinomialSynapses.jl","title":"BinomialSynapses.BinomialGridModel","text":"BinomialGridModel(m_out, my_Nrng, my_prng, my_qrng, my_σrng, my_τrng)\n\nRandomly initialize a binomial model ensemble with parameters uniformly sampled from the specified grid (on the GPU).\n\n\n\n\n\n","category":"method"},{"location":"#BinomialSynapses.BinomialModel","page":"BinomialSynapses.jl","title":"BinomialSynapses.BinomialModel","text":"BinomialModel(N, p, q, σ, τ)\n\nThe standard structure for a binomial model or model ensemble.\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.BinomialModel-2","page":"BinomialSynapses.jl","title":"BinomialSynapses.BinomialModel","text":"BinomialModel(Nmax, m_out, device = :gpu)\n\nRandomly initialize a binomial model ensemble of size m_out, with maximum value for N of Nmax on the GPU or CPU.\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.BinomialModel-Tuple{Integer, Any, Any, Any, Any, Any}","page":"BinomialSynapses.jl","title":"BinomialSynapses.BinomialModel","text":"BinomialModel(m_out, my_Nrng, my_prng, my_qrng, my_σrng, my_τrng)\n\nRandomly initialize a binomial model ensemble on a grid, but throw away the grid info and just keep the parameters.\n\n\n\n\n\n","category":"method"},{"location":"#BinomialSynapses.BinomialModel-Tuple{BinomialGridModel}","page":"BinomialSynapses.jl","title":"BinomialSynapses.BinomialModel","text":"BinomialModel(model::BinomialGridModel)\n\nConvert a BinomialGridModel into a BinomialModel.\n\n\n\n\n\n","category":"method"},{"location":"#BinomialSynapses.ScalarBinomialModel","page":"BinomialSynapses.jl","title":"BinomialSynapses.ScalarBinomialModel","text":"ScalarBinomialModel(Nmax, device = :cpu)\n\nRandomly initialize a model ensemble of size 1, which corresponds to a scalar model (used for the hidden state).\n\n\n\n\n\nScalarBinomialModel(N, p, q, σ, τ, device = :cpu)\n\nInitialize a scalar binomial model with the given parameters.\n\n\n\n\n\n","category":"function"},{"location":"#BinomialSynapses.BinomialState","page":"BinomialSynapses.jl","title":"BinomialSynapses.BinomialState","text":"BinomialState(Nmax, m_out, m_in, device = :gpu)\n\nRandomly initialize a state ensemble of size m_out x m_in and maximum value of N  equal to Nmax on the specified device :gpu or :cpu.\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.ScalarBinomialState","page":"BinomialSynapses.jl","title":"BinomialSynapses.ScalarBinomialState","text":"ScalarBinomialState(Nmax, device = :cpu)\n\nRandomly initialize a state ensemble of size 1, which corresponds to a scalar model (used for the hidden state).\n\n\n\n\n\nScalarBinomialState(n, k, device = :cpu)\n\nInitialize a scalar state with the specified values of the variables.\n\n\n\n\n\n","category":"function"},{"location":"#BinomialSynapses.BinomialObservation","page":"BinomialSynapses.jl","title":"BinomialSynapses.BinomialObservation","text":"BinomialObservation\n\nA structure for an observation consisting of an EPSP and a time step.\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.propagate!-Tuple{BinomialState, Any, Any}","page":"BinomialSynapses.jl","title":"BinomialSynapses.propagate!","text":"propagate!(state, model, dt)\n\nPropagate state forward according to the model, given a time step dt.\n\n\n\n\n\n","category":"method"},{"location":"#BinomialSynapses.emit","page":"BinomialSynapses.jl","title":"BinomialSynapses.emit","text":"emit(state, model, timestep)\n\nReturn a BinomialObservation based on the current state and model, after a  speficied time step timestep.\n\n\n\n\n\nemit(sim, dt)\n\nEmit an EPSP after time step dt.\n\n\n\n\n\n","category":"function"},{"location":"#Time-steps","page":"BinomialSynapses.jl","title":"Time steps","text":"","category":"section"},{"location":"","page":"BinomialSynapses.jl","title":"BinomialSynapses.jl","text":"Timestep\nFixedTimestep\nRandomTimestep\nget_step","category":"page"},{"location":"#BinomialSynapses.Timestep","page":"BinomialSynapses.jl","title":"BinomialSynapses.Timestep","text":"Timestep\n\nAn abstract type specifying the way a time step is chosen.  The following basic types are supported:\n\nFixedTimestep: a constant, fixed number is used\nRandomTimestep: the time step is random from a fixed distribution\nOEDPolicy: an optimal time step is chosen based on some objective function\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.FixedTimestep","page":"BinomialSynapses.jl","title":"BinomialSynapses.FixedTimestep","text":"FixedTimestep(dt)\n\nChoose a fixed time step of size `dt`.\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.RandomTimestep","page":"BinomialSynapses.jl","title":"BinomialSynapses.RandomTimestep","text":"RandomTimestep(dist)\n\nChoose a random time step from distribution dist. There must be an implementation of rand for typeof(dist).\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.get_step","page":"BinomialSynapses.jl","title":"BinomialSynapses.get_step","text":"get_step(::Timestep)\n\nReturns a value for the time step, based on the chosen method for choosing a time step.\n\n\n\n\n\n","category":"function"},{"location":"#Particle-Filter","page":"BinomialSynapses.jl","title":"Particle Filter","text":"","category":"section"},{"location":"","page":"BinomialSynapses.jl","title":"BinomialSynapses.jl","text":"NestedParticleFilter\nNestedParticleState\nNestedParticleState(\n    m_out::Integer, m_in::Integer,\n    my_Nrng, my_prng, my_qrng, my_σrng, my_τrng\n)\nupdate!(\n    filterstate::NestedParticleState,\n    observation::BinomialObservation,\n    filter::NestedParticleFilter\n)\njitter!\nlikelihood\nlikelihood_resample!\nouter_resample!\nindices!\nresample!","category":"page"},{"location":"#BinomialSynapses.NestedParticleFilter","page":"BinomialSynapses.jl","title":"BinomialSynapses.NestedParticleFilter","text":"NestedParticleFilter(jittering_width)\n\nConstruct a nested particle filter with a given jittering kernel width parameter.\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.NestedParticleState","page":"BinomialSynapses.jl","title":"BinomialSynapses.NestedParticleState","text":"NestedParticleState(state, model)\n\nConstruct a particle system (ensemble) consisting of a state ensemble (inner and outer particles) and a model ensemble (outer particles).\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.NestedParticleState-Tuple{Integer, Integer, Any, Any, Any, Any, Any}","page":"BinomialSynapses.jl","title":"BinomialSynapses.NestedParticleState","text":"NestedParticleState(m_out, m_in, my_Nrng, my_prng, my_qrng, my_σrng, my_τrng)\n\nConstruct a randomly initialized particle system with a given number of outer (m_out) and inner (m_in) particles and specified grids for the parameters.\n\n\n\n\n\n","category":"method"},{"location":"#BinomialSynapses.update!-Tuple{NestedParticleState, BinomialObservation, NestedParticleFilter}","page":"BinomialSynapses.jl","title":"BinomialSynapses.update!","text":"update!(filterstate, obs, filter)\n\nUpdate the particle filter state based on a given observation and filter.\n\n\n\n\n\n","category":"method"},{"location":"#BinomialSynapses.jitter!","page":"BinomialSynapses.jl","title":"BinomialSynapses.jitter!","text":"jitter!(model::BinomialGridModel, width)\n\nApply jitter with parameter width to the indices of a binomial model on a grid.\n\n\n\n\n\n","category":"function"},{"location":"#BinomialSynapses.likelihood","page":"BinomialSynapses.jl","title":"BinomialSynapses.likelihood","text":"likelihood(state, model::AbstractBinomialModel, obs)\n\nReturn the likelihood of an observation conditioned on the current state and model. This broadcasts properly over state and model ensemble, if they have compatible sizes.\n\n\n\n\n\n","category":"function"},{"location":"#BinomialSynapses.likelihood_resample!","page":"BinomialSynapses.jl","title":"BinomialSynapses.likelihood_resample!","text":"likelihood_resample!(state, model::AbstractBinomialModel, obs)\n\nReturn the likelihood of an observation conditioned on the current state and model ensemble and at the same time resample the state ensemble (inner particles).\n\n\n\n\n\n","category":"function"},{"location":"#BinomialSynapses.outer_resample!","page":"BinomialSynapses.jl","title":"BinomialSynapses.outer_resample!","text":"outer_resample!(state, model, u)\n\nResample the outer particles of the state and model ensemble based on their likelihoods u.\n\n\n\n\n\n","category":"function"},{"location":"#BinomialSynapses.indices!","page":"BinomialSynapses.jl","title":"BinomialSynapses.indices!","text":"indices!(v)\n\nReturn index table and total likelihoods from likelihood table v. This function modifies v; after execution, v will be the cumulative sum of the original v along the last dimension.\n\n\n\n\n\n","category":"function"},{"location":"#BinomialSynapses.resample!","page":"BinomialSynapses.jl","title":"BinomialSynapses.resample!","text":"resample!(state, idx)\nresample!(model, idx)\n\nResample the outer particles of state or model ensembles based on index table idx.\n\n\n\n\n\n","category":"function"},{"location":"#OED","page":"BinomialSynapses.jl","title":"OED","text":"","category":"section"},{"location":"","page":"BinomialSynapses.jl","title":"BinomialSynapses.jl","text":"OEDPolicy\npolicy\nUniform\nMyopicPolicy\nMyopic\nMyopicFast\nMyopic_tau\nMyopicFast_tau","category":"page"},{"location":"#BinomialSynapses.OEDPolicy","page":"BinomialSynapses.jl","title":"BinomialSynapses.OEDPolicy","text":"OEDPolicy <: Timestep\n\nAn abstract type for choosing time steps based on optimizing a given cost function. This is provided in order to do active inference.\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.policy","page":"BinomialSynapses.jl","title":"BinomialSynapses.policy","text":"policy(sim)\n\nReturn the instance of OEDPolicy used in simulation sim.\n\n\n\n\n\n","category":"function"},{"location":"#BinomialSynapses.Uniform","page":"BinomialSynapses.jl","title":"BinomialSynapses.Uniform","text":"Uniform(dts)\n\nRandomly sample from a discrete set of time steps dts. This is equivalent to, but more convenient to use than RandomTimestep(dist) with dist a uniform distribution on dts. \n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.MyopicPolicy","page":"BinomialSynapses.jl","title":"BinomialSynapses.MyopicPolicy","text":"MyopicPolicy <: OEDPolicy\n\nA myopic OEDPolicy, i.e. one in which only the effect of the next time step on the parameter estimation, e.g. the entropy of a parameter, is taken into account.\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.Myopic","page":"BinomialSynapses.jl","title":"BinomialSynapses.Myopic","text":"Myopic(dts, target)\n\nA parallel implementation of a myopic policy with candidate time steps dts and optimization target target, in which multiple copies of the particles  are propagated in parallel.\n\nImplemented settings of target: choose time step such that it\n\n_entropy: minimizes the joint entropy of the posterior distribution over parameters\n_tauentropy: minimizes the marginal entropy of τ\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.MyopicFast","page":"BinomialSynapses.jl","title":"BinomialSynapses.MyopicFast","text":"MyopicFast(dts, target)\n\nMyopicFastis the same asMyopic, except that instead of expanding states and parameters along another dimension, and propagating each parameter with each dt,dts` are randomly assigned to members of the parameter ensemble.\n\nImplemented settings of target: choose time step such that it\n\n_entropy: minimizes the joint entropy of the posterior distribution over parameters\n_tauentropy: minimizes the marginal entropy of τ\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.Myopic_tau","page":"BinomialSynapses.jl","title":"BinomialSynapses.Myopic_tau","text":"Myopic_tau(dts)\n\nMinimize the entropy of τ.\n\n\n\n\n\n","category":"function"},{"location":"#BinomialSynapses.MyopicFast_tau","page":"BinomialSynapses.jl","title":"BinomialSynapses.MyopicFast_tau","text":"MyopicFast_tau(dts)\n\nMinimize the entropy of τ.\n\n\n\n\n\n","category":"function"},{"location":"#Simulation","page":"BinomialSynapses.jl","title":"Simulation","text":"","category":"section"},{"location":"","page":"BinomialSynapses.jl","title":"BinomialSynapses.jl","text":"NestedFilterSimulation\ninitialize!\npropagate!(sim::NestedFilterSimulation)\nrun!\nRecording\nupdate!(rec::Recording, sim, time)\nsave","category":"page"},{"location":"#BinomialSynapses.NestedFilterSimulation","page":"BinomialSynapses.jl","title":"BinomialSynapses.NestedFilterSimulation","text":"NestedFilterSimulation(hmodel, filter, hstate, fstate, tsteps, times, epsps)\n\nThis object stores static (hmodel, filter, tsteps) and dynamic (hstate, fstate, tsteps, times, epsps) information about the simulation.\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.initialize!","page":"BinomialSynapses.jl","title":"BinomialSynapses.initialize!","text":"initialize!(sim)\n\nInitialize the simulation.\n\n\n\n\n\n","category":"function"},{"location":"#BinomialSynapses.propagate!-Tuple{NestedFilterSimulation}","page":"BinomialSynapses.jl","title":"BinomialSynapses.propagate!","text":"propagate!(sim)\n\nPropagate the simulation, i.e. choose a time step and then propagate the simulation by it.\n\n\n\n\n\n","category":"method"},{"location":"#BinomialSynapses.run!","page":"BinomialSynapses.jl","title":"BinomialSynapses.run!","text":"run!(\n    sim; \n    T, \n    plot_each_timestep = false, \n    recording = NoRecording\n)\n\nRun a simulation for T time steps. Set plot_each_timestep = true to get a live update of the simulation (this will reduce performance) and set recording to collect data while running the simulation (see Recording).\n\n\n\n\n\n","category":"function"},{"location":"#BinomialSynapses.Recording","page":"BinomialSynapses.jl","title":"BinomialSynapses.Recording","text":"Recording(f1, f2, data)\n\nA recording, which is stored in data. The function f1 is something that is computed at each time step, whereas f2 is an operation that is applied after the simulation is finished.\n\n\n\n\n\n","category":"type"},{"location":"#BinomialSynapses.update!-Tuple{Recording, Any, Any}","page":"BinomialSynapses.jl","title":"BinomialSynapses.update!","text":"update!(rec::Recording, sim, time)\n\nCompute f1(sim, time) and store it in rec.data.\n\n\n\n\n\n","category":"method"},{"location":"#BinomialSynapses.save","page":"BinomialSynapses.jl","title":"BinomialSynapses.save","text":"save(rec::Recording)\n\nApply f2 to data.\n\n\n\n\n\n","category":"function"}]
}
